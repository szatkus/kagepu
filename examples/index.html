<script src="/kagepu.js"></script>
<script>
    // this is a port of https://github.com/gfx-rs/wgpu/blob/master/examples/hello_triangle_rust/main.rs
    window.onload = async () => {
        let adapter = await kagepu.requestAdapter({
            powerPreference: 'low-power'
        });
        let device = await adapter.requestDevice({
            extensions: {
                anisotropic_filtering: false,
            }
        });

        //let vs_bytes = include_bytes!("./../data/hello_triangle.vert.spv");
        let vs_module = device.createShaderModule({});
        //let fs_bytes = include_bytes!("./../data/hello_triangle.frag.spv");
        let fs_module = device.createShaderModule({});

        let bind_group_layout =
            device.createBindGroupLayout({ bindings: [] });
        let pipeline_layout = device.createPipelineLayout({
            bindGroupLayouts: [bind_group_layout],
        });

        let render_pipeline = device.createRenderPipeline({
            layout: pipeline_layout,
            vertex_stage: {
                module: vs_module,
                entryPoint: "main",
            },
            fragment_stage: {
                module: fs_module,
                entryPoint: "main",
            },
            rasterization_state: {
                front_face: 'Ccw',
                cull_mode: 'None',
                depth_bias: 0,
                depth_bias_slope_scale: 0.0,
                depth_bias_clamp: 0.0,
            },
            primitive_topology: 'TriangleList',
            color_states: [{
                format: 'Bgra8Unorm',
                color: 'REPLACE',
                alpha: 'REPLACE',
                write_mask: 'ALL',
            }],
            depth_stencil_state: 'None',
            index_format: 'Uint16',
            vertex_buffers: [],
            sample_count: 1,
        });

    //     use wgpu::winit::{
    //         ControlFlow, ElementState, Event, EventsLoop, KeyboardInput, VirtualKeyCode, Window,
    //         WindowEvent,
    //     };

    //     let mut events_loop = EventsLoop::new();
    //     let window = Window::new(&events_loop).unwrap();
    //     let size = window
    //         .get_inner_size()
    //         .unwrap()
    //         .to_physical(window.get_hidpi_factor());

    //     let surface = instance.create_surface(&window);
    //     let mut swap_chain = device.create_swap_chain(
    //         &surface,
    //         &wgpu::SwapChainDescriptor {
    //             usage: wgpu::TextureUsageFlags::OUTPUT_ATTACHMENT,
    //             format: wgpu::TextureFormat::Bgra8Unorm,
    //             width: size.width as u32,
    //             height: size.height as u32,
    //         },
    //     );

    //     events_loop.run_forever(|event| {
    //         match event {
    //             Event::WindowEvent { event, .. } => match event {
    //                 WindowEvent::KeyboardInput {
    //                     input:
    //                         KeyboardInput {
    //                             virtual_keycode: Some(code),
    //                             state: ElementState::Pressed,
    //                             ..
    //                         },
    //                     ..
    //                 } => match code {
    //                     VirtualKeyCode::Escape => return ControlFlow::Break,
    //                     _ => {}
    //                 },
    //                 WindowEvent::CloseRequested => return ControlFlow::Break,
    //                 _ => {}
    //             },
    //             _ => {}
    //         }

    //         let frame = swap_chain.get_next_texture();
    //         let mut encoder =
    //             device.create_command_encoder(&wgpu::CommandEncoderDescriptor { todo: 0 });
    //         {
    //             let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
    //                 color_attachments: &[wgpu::RenderPassColorAttachmentDescriptor {
    //                     attachment: &frame.view,
    //                     load_op: wgpu::LoadOp::Clear,
    //                     store_op: wgpu::StoreOp::Store,
    //                     clear_color: wgpu::Color::GREEN,
    //                 }],
    //                 depth_stencil_attachment: None,
    //             });
    //             rpass.set_pipeline(&render_pipeline);
    //             rpass.draw(0..3, 0..1);
    //         }

    //         device.get_queue().submit(&[encoder.finish()]);

    //         ControlFlow::Continue
    //     });
    // }
    }
</script>
