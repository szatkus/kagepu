!function(e){var t={};function n(a){if(t[a])return t[a].exports;var o=t[a]={i:a,l:!1,exports:{}};return e[a].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(a,o,function(t){return e[t]}.bind(null,o));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="dist/",n(n.s=18)}({18:function(e,t,n){"use strict";n.r(t),n.d(t,"title",(function(){return r})),n.d(t,"description",(function(){return i})),n.d(t,"init",(function(){return s}));var a=n(2),o=function(e,t,n,a){return new(n||(n=Promise))((function(o,r){function i(e){try{c(a.next(e))}catch(e){r(e)}}function s(e){try{c(a.throw(e))}catch(e){r(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,s)}c((a=a.apply(e,t||[])).next())}))};const r="Compute Boids",i="A GPU compute particle simulation that mimics                             the flocking behavior of birds. A compute shader updates                             two ping-pong buffers which store particle data. The data                             is used to draw instanced particles.";function s(e){return o(this,void 0,void 0,(function*(){const t=yield navigator.gpu.requestAdapter(),n=yield t.requestDevice(),o=yield Object(a.a)(),r=e.getContext("gpupresent").configureSwapChain({device:n,format:"bgra8unorm"}),i=n.createBindGroupLayout({bindings:[{binding:0,visibility:GPUShaderStage.COMPUTE,type:"uniform-buffer"},{binding:1,visibility:GPUShaderStage.COMPUTE,type:"storage-buffer"},{binding:2,visibility:GPUShaderStage.COMPUTE,type:"storage-buffer"}]}),s=n.createPipelineLayout({bindGroupLayouts:[i]}),c=n.createRenderPipeline({layout:n.createPipelineLayout({bindGroupLayouts:[]}),vertexStage:{module:n.createShaderModule({code:o.compileGLSL("#version 450\n  layout(location = 0) in vec2 a_particlePos;\n  layout(location = 1) in vec2 a_particleVel;\n  layout(location = 2) in vec2 a_pos;\n  void main() {\n    float angle = -atan(a_particleVel.x, a_particleVel.y);\n    vec2 pos = vec2(a_pos.x * cos(angle) - a_pos.y * sin(angle),\n            a_pos.x * sin(angle) + a_pos.y * cos(angle));\n    gl_Position = vec4(pos + a_particlePos, 0, 1);\n  }","vertex")}),entryPoint:"main"},fragmentStage:{module:n.createShaderModule({code:o.compileGLSL("#version 450\n  layout(location = 0) out vec4 fragColor;\n  void main() {\n    fragColor = vec4(1.0);\n  }","fragment")}),entryPoint:"main"},primitiveTopology:"triangle-list",depthStencilState:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"},vertexInput:{vertexBuffers:[{stride:16,stepMode:"instance",attributeSet:[{shaderLocation:0,offset:0,format:"float2"},{shaderLocation:1,offset:8,format:"float2"}]},{stride:8,stepMode:"vertex",attributeSet:[{shaderLocation:2,offset:0,format:"float2"}]}]},colorStates:[{format:"bgra8unorm"}]}),l=n.createComputePipeline({layout:s,computeStage:{module:n.createShaderModule({code:o.compileGLSL("#version 450\n  struct Particle {\n    vec2 pos;\n    vec2 vel;\n  };\n\n  layout(std140, set = 0, binding = 0) uniform SimParams {\n    float deltaT;\n    float rule1Distance;\n    float rule2Distance;\n    float rule3Distance;\n    float rule1Scale;\n    float rule2Scale;\n    float rule3Scale;\n  } params;\n\n  layout(std140, set = 0, binding = 1) buffer ParticlesA {\n    Particle particles[1500];\n  } particlesA;\n\n  layout(std140, set = 0, binding = 2) buffer ParticlesB {\n    Particle particles[1500];\n  } particlesB;\n\n  void main() {\n    // https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp\n\n    uint index = gl_GlobalInvocationID.x;\n    if (index >= 1500) { return; }\n\n    vec2 vPos = particlesA.particles[index].pos;\n    vec2 vVel = particlesA.particles[index].vel;\n\n    vec2 cMass = vec2(0.0, 0.0);\n    vec2 cVel = vec2(0.0, 0.0);\n    vec2 colVel = vec2(0.0, 0.0);\n    int cMassCount = 0;\n    int cVelCount = 0;\n\n    vec2 pos;\n    vec2 vel;\n    for (int i = 0; i < 1500; ++i) {\n      if (i == index) { continue; }\n      pos = particlesA.particles[i].pos.xy;\n      vel = particlesA.particles[i].vel.xy;\n\n      if (distance(pos, vPos) < params.rule1Distance) {\n        cMass += pos;\n        cMassCount++;\n      }\n      if (distance(pos, vPos) < params.rule2Distance) {\n        colVel -= (pos - vPos);\n      }\n      if (distance(pos, vPos) < params.rule3Distance) {\n        cVel += vel;\n        cVelCount++;\n      }\n    }\n    if (cMassCount > 0) {\n      cMass = cMass / cMassCount - vPos;\n    }\n    if (cVelCount > 0) {\n      cVel = cVel / cVelCount;\n    }\n\n    vVel += cMass * params.rule1Scale + colVel * params.rule2Scale + cVel * params.rule3Scale;\n\n    // clamp velocity for a more pleasing simulation.\n    vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);\n\n    // kinematic update\n    vPos += vVel * params.deltaT;\n\n    // Wrap around boundary\n    if (vPos.x < -1.0) vPos.x = 1.0;\n    if (vPos.x > 1.0) vPos.x = -1.0;\n    if (vPos.y < -1.0) vPos.y = 1.0;\n    if (vPos.y > 1.0) vPos.y = -1.0;\n\n    particlesB.particles[index].pos = vPos;\n\n    // Write back\n    particlesB.particles[index].vel = vVel;\n  }","compute")}),entryPoint:"main"}}),u={colorAttachments:[{attachment:void 0,loadValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{attachment:n.createTexture({size:{width:e.width,height:e.height,depth:1},format:"depth24plus-stencil8",usage:GPUTextureUsage.OUTPUT_ATTACHMENT}).createView(),depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},f=new Float32Array([-.01,-.02,.01,-.02,0,.02]),p=n.createBuffer({size:f.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});p.setSubData(0,f);const d=new Float32Array([.04,.1,.025,.025,.02,.05,.005]),v=n.createBuffer({size:d.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});v.setSubData(0,d);const g=new Float32Array(6e3);for(let e=0;e<1500;++e)g[4*e+0]=2*(Math.random()-.5),g[4*e+1]=2*(Math.random()-.5),g[4*e+2]=2*(Math.random()-.5)*.1,g[4*e+3]=2*(Math.random()-.5)*.1;const m=new Array(2),y=new Array(2);for(let e=0;e<2;++e)m[e]=n.createBuffer({size:g.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE}),m[e].setSubData(0,g);for(let e=0;e<2;++e)y[e]=n.createBindGroup({layout:i,bindings:[{binding:0,resource:{buffer:v,offset:0,size:d.byteLength}},{binding:1,resource:{buffer:m[e],offset:0,size:g.byteLength}},{binding:2,resource:{buffer:m[(e+1)%2],offset:0,size:g.byteLength}}]});let b=0;return function(){u.colorAttachments[0].attachment=r.getCurrentTexture().createView();const e=n.createCommandEncoder({});{const t=e.beginComputePass();t.setPipeline(l),t.setBindGroup(0,y[b%2]),t.dispatch(1500),t.endPass()}{const t=e.beginRenderPass(u);t.setPipeline(c),t.setVertexBuffer(0,m[(b+1)%2]),t.setVertexBuffer(1,p),t.draw(3,1500,0,0),t.endPass()}n.getQueue().submit([e.finish()]),++b}}))}},2:function(e,t,n){"use strict";var a=function(e,t,n,a){return new(n||(n=Promise))((function(o,r){function i(e){try{c(a.next(e))}catch(e){r(e)}}function s(e){try{c(a.throw(e))}catch(e){r(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,s)}c((a=a.apply(e,t||[])).next())}))};let o=void 0;t.a=function(){return a(this,void 0,void 0,(function*(){if(void 0!==o)return o;const e=yield import("https://unpkg.com/@webgpu/glslang@0.0.7/web/glslang.js");return o=yield e.default()}))}}});
//# sourceMappingURL=computeBoids.js.map