!function(e){var t={};function n(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,n),r.l=!0,r.exports}n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(a,r,function(t){return e[t]}.bind(null,r));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="dist/",n(n.s=19)}({19:function(e,t,n){"use strict";n.r(t),n.d(t,"title",(function(){return o})),n.d(t,"description",(function(){return i})),n.d(t,"init",(function(){return s}));var a=n(2),r=function(e,t,n,a){return new(n||(n=Promise))((function(r,o){function i(e){try{c(a.next(e))}catch(e){o(e)}}function s(e){try{c(a.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,s)}c((a=a.apply(e,t||[])).next())}))};const o="Compute Boids",i="A GPU compute particle simulation that mimics                             the flocking behavior of birds. A compute shader updates                             two ping-pong buffers which store particle data. The data                             is used to draw instanced particles.";function s(e){return r(this,void 0,void 0,(function*(){const t="#version 450\n  layout(location = 0) in vec2 a_particlePos;\n  layout(location = 1) in vec2 a_particleVel;\n  layout(location = 2) in vec2 a_pos;\n  void main() {\n    float angle = -atan(a_particleVel.x, a_particleVel.y);\n    vec2 pos = vec2(a_pos.x * cos(angle) - a_pos.y * sin(angle),\n            a_pos.x * sin(angle) + a_pos.y * cos(angle));\n    gl_Position = vec4(pos + a_particlePos, 0, 1);\n  }",n="#version 450\n  layout(location = 0) out vec4 fragColor;\n  void main() {\n    fragColor = vec4(1.0);\n  }",r="#version 450\n  struct Particle {\n    vec2 pos;\n    vec2 vel;\n  };\n\n  layout(std140, set = 0, binding = 0) uniform SimParams {\n    float deltaT;\n    float rule1Distance;\n    float rule2Distance;\n    float rule3Distance;\n    float rule1Scale;\n    float rule2Scale;\n    float rule3Scale;\n  } params;\n\n  layout(std140, set = 0, binding = 1) buffer ParticlesA {\n    Particle particles[1500];\n  } particlesA;\n\n  layout(std140, set = 0, binding = 2) buffer ParticlesB {\n    Particle particles[1500];\n  } particlesB;\n\n  void main() {\n    // https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp\n\n    uint index = gl_GlobalInvocationID.x;\n    if (index >= 1500) { return; }\n\n    vec2 vPos = particlesA.particles[index].pos;\n    vec2 vVel = particlesA.particles[index].vel;\n\n    vec2 cMass = vec2(0.0, 0.0);\n    vec2 cVel = vec2(0.0, 0.0);\n    vec2 colVel = vec2(0.0, 0.0);\n    int cMassCount = 0;\n    int cVelCount = 0;\n\n    vec2 pos;\n    vec2 vel;\n    for (int i = 0; i < 1500; ++i) {\n      if (i == index) { continue; }\n      pos = particlesA.particles[i].pos.xy;\n      vel = particlesA.particles[i].vel.xy;\n\n      if (distance(pos, vPos) < params.rule1Distance) {\n        cMass += pos;\n        cMassCount++;\n      }\n      if (distance(pos, vPos) < params.rule2Distance) {\n        colVel -= (pos - vPos);\n      }\n      if (distance(pos, vPos) < params.rule3Distance) {\n        cVel += vel;\n        cVelCount++;\n      }\n    }\n    if (cMassCount > 0) {\n      cMass = cMass / cMassCount - vPos;\n    }\n    if (cVelCount > 0) {\n      cVel = cVel / cVelCount;\n    }\n\n    vVel += cMass * params.rule1Scale + colVel * params.rule2Scale + cVel * params.rule3Scale;\n\n    // clamp velocity for a more pleasing simulation.\n    vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);\n\n    // kinematic update\n    vPos += vVel * params.deltaT;\n\n    // Wrap around boundary\n    if (vPos.x < -1.0) vPos.x = 1.0;\n    if (vPos.x > 1.0) vPos.x = -1.0;\n    if (vPos.y < -1.0) vPos.y = 1.0;\n    if (vPos.y > 1.0) vPos.y = -1.0;\n\n    particlesB.particles[index].pos = vPos;\n\n    // Write back\n    particlesB.particles[index].vel = vVel;\n  }",o=yield navigator.gpu.requestAdapter(),i=yield o.requestDevice(),s=yield Object(a.a)(),c=e.getContext("gpupresent").configureSwapChain({device:i,format:"bgra8unorm"}),l=i.createBindGroupLayout({bindings:[{binding:0,visibility:GPUShaderStage.COMPUTE,type:"uniform-buffer"},{binding:1,visibility:GPUShaderStage.COMPUTE,type:"storage-buffer"},{binding:2,visibility:GPUShaderStage.COMPUTE,type:"storage-buffer"}]}),u=i.createPipelineLayout({bindGroupLayouts:[l]}),f=i.createRenderPipeline({layout:i.createPipelineLayout({bindGroupLayouts:[]}),vertexStage:{module:i.createShaderModule({code:s.compileGLSL(t,"vertex"),source:t,transform:e=>s.compileGLSL(e,"vertex")}),entryPoint:"main"},fragmentStage:{module:i.createShaderModule({code:s.compileGLSL(n,"fragment"),source:n,transform:e=>s.compileGLSL(e,"fragment")}),entryPoint:"main"},primitiveTopology:"triangle-list",depthStencilState:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"},vertexState:{vertexBuffers:[{arrayStride:16,stepMode:"instance",attributes:[{shaderLocation:0,offset:0,format:"float2"},{shaderLocation:1,offset:8,format:"float2"}]},{arrayStride:8,stepMode:"vertex",attributes:[{shaderLocation:2,offset:0,format:"float2"}]}]},colorStates:[{format:"bgra8unorm"}]}),p=i.createComputePipeline({layout:u,computeStage:{module:i.createShaderModule({code:s.compileGLSL(r,"compute"),source:r,transform:e=>s.compileGLSL(e,"compute")}),entryPoint:"main"}}),d={colorAttachments:[{attachment:void 0,loadValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{attachment:i.createTexture({size:{width:e.width,height:e.height,depth:1},format:"depth24plus-stencil8",usage:GPUTextureUsage.OUTPUT_ATTACHMENT}).createView(),depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},v=new Float32Array([-.01,-.02,.01,-.02,0,.02]),m=i.createBuffer({size:v.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});m.setSubData(0,v);const g=new Float32Array([.04,.1,.025,.025,.02,.05,.005]),y=i.createBuffer({size:g.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});y.setSubData(0,g);const b=new Float32Array(6e3);for(let e=0;e<1500;++e)b[4*e+0]=2*(Math.random()-.5),b[4*e+1]=2*(Math.random()-.5),b[4*e+2]=2*(Math.random()-.5)*.1,b[4*e+3]=2*(Math.random()-.5)*.1;const h=new Array(2),P=new Array(2);for(let e=0;e<2;++e)h[e]=i.createBuffer({size:b.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE}),h[e].setSubData(0,b);for(let e=0;e<2;++e)P[e]=i.createBindGroup({layout:l,bindings:[{binding:0,resource:{buffer:y,offset:0,size:g.byteLength}},{binding:1,resource:{buffer:h[e],offset:0,size:b.byteLength}},{binding:2,resource:{buffer:h[(e+1)%2],offset:0,size:b.byteLength}}]});let S=0;return function(){d.colorAttachments[0].attachment=c.getCurrentTexture().createView();const e=i.createCommandEncoder({});{const t=e.beginComputePass();t.setPipeline(p),t.setBindGroup(0,P[S%2]),t.dispatch(1500),t.endPass()}{const t=e.beginRenderPass(d);t.setPipeline(f),t.setVertexBuffer(0,h[(S+1)%2]),t.setVertexBuffer(1,m),t.draw(3,1500,0,0),t.endPass()}i.defaultQueue.submit([e.finish()]),++S}}))}},2:function(e,t,n){"use strict";var a=function(e,t,n,a){return new(n||(n=Promise))((function(r,o){function i(e){try{c(a.next(e))}catch(e){o(e)}}function s(e){try{c(a.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,s)}c((a=a.apply(e,t||[])).next())}))};let r=void 0;t.a=function(){return a(this,void 0,void 0,(function*(){if(void 0!==r)return r;const e=yield import("https://unpkg.com/@webgpu/glslang@0.0.7/web/glslang.js");return r=yield e.default(),r}))}}});
//# sourceMappingURL=computeBoids-bbae37.js.map